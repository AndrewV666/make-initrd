#!/bin/sh

verbose() {
	[ -n "$QUIET" ] || echo "$@"
}

shell() {
	# Disallow console access
	[ "$PANIC" != 0 ] || reboot

	if [ -n "$RESCUE_MODULES" ]; then
		local m
		for m in $RESCUE_MODULES; do
			modprobe -q "$m"
		done
	fi
	echo "$@"
	PS1='(initramfs) ' /bin/sh -i </dev/console >/dev/console 2>&1
}

run_scripts() {
	local s
	for s in /scripts/"$1"/*; do
		[ -x "$s" ] || continue
		verbose "Running $s ..."
		. "$s"
	done
}

load_modules() {
	[ ! -e /conf/modules-"$1" ] ||
	while read m; do
		[ -n "${m##\#*}" ] || continue
		modprobe -q $m
	done < /conf/modules-"$1"
}

configure_network() {
	# networking already configured thus bail out
	[ -n "$DEVICE" ] && [ -e /tmp/net-"$DEVICE".conf ] && return 0

	# support ip options see linux sources Documentation/nfsroot.txt
	case "$IPOPTS" in
		none|off)
			# Do nothing
			;;
		""|on|any)
			# Bring up device
			ipconfig "$DEVICE"
			;;
		dhcp|bootp|rarp|both)
			ipconfig -c "$IPOPTS" -d "$DEVICE"
			;;
		*)
			ipconfig -d "$IPOPTS"

			# grab device entry from ip option
			NEW_DEVICE="${IPOPTS#*:*:*:*:*:*}"
			if [ "$NEW_DEVICE" != "$IPOPTS" ]; then
				NEW_DEVICE="${NEW_DEVICE%:*}"
			else
				# wrong parse, possibly only a partial string
				NEW_DEVICE=
			fi
			if [ -n "$NEW_DEVICE" ]; then
				DEVICE="$NEW_DEVICE"
			fi
			;;
	esac

	# source relevant ipconfig output
	. /tmp/net-${DEVICE}.conf
}

get_dev() {
	local name retval value
	retval="$1"; shift
	name="$1"; shift

	case "$name" in
		UUID=*)
			[ "$ID_FS_UUID" = "${name#UUID=}" ] ||
				return 1
			;;
		LABEL=*)
			[ "$ID_FS_LABEL" = "${name#LABEL=}" ] ||
				return 1
			;;
		/*)
			[ "$DEVNAME" = "$name" ] ||
				return 1
			;;
		*:*)
			[ "$MAJOR" = "${name%:*}" -a "$MINOR" = "${name#*:}" ] ||
				return 1
			;;
		*)
			local value=$(( 0x$name ))
			[ "$MAJOR" = "$(( $value / 256 ))" -a "$MINOR" = "$(( $value % 256 ))" ] ||
				return 1
			;;
	esac
	eval "$retval=\"\$DEVNAME\""
}
