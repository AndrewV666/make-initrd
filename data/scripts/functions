#!/bin/sh

message() {
	printf 'initrd:%s %s\n' "${stage:+ $stage:}" "$*"
}

error() {
	message "ERROR: $*"
}

debug() {
	[ -z "$DEBUG" ] || message "$@"
}

verbose() {
	[ -n "$QUIET" ] || message "$@"
}

makenod() {
	[ -e /dev/$1 ] || mknod /dev/$1 $2 $3 $4
}

modprobe_check() {
	local s
	for s in /scripts/kmodules/*check-"$1"; do
		if [ -x "$s" ]; then
			"$s" || return 0
		fi
	done
	modprobe -q "$1"
}

shell() {
	# Disallow console access
	[ "$PANIC" != 0 ] || reboot

	if [ -n "$RESCUE_MODULES" ]; then
		local kmod
		for kmod in $RESCUE_MODULES; do
			modprobe_check "$kmod"
		done
	fi

	run_scripts 'pre/shell'

	[ "$#" -eq 0 ] || message "$@"
	message "This shell remains here for debug purposes. Press Ctrl-D to continue."
	PS1='(initramfs) ' /bin/sh -i +m

	run_scripts 'post/shell'
}

run_module() {
	local stage
	export stage="$1"
	shift
	run "$@"
}

run_scripts() {
	local s
	for s in /scripts/all/* /scripts/"$1"/*; do
		[ -x "$s" ] || continue
		verbose "Running $s ..."
		. "$s"
	done
}

load_modules() {
	[ ! -e /conf/modules-"$1" ] ||
	while read m; do
		[ -n "${m##\#*}" ] || continue
		modprobe_check "$m"
	done < /conf/modules-"$1"
}

dir_not_empty() {
	local f
	for f in "$1"/*; do
		[ -e "$f" ] ||
			return 1
		return 0
	done
}

mk_event() {
	mkdir -p -- "$udev_eventdir/$1"
	mktemp "$udev_eventdir/$1"/event.XXXXXXXXX
}

devlinks_check() {
	local l
	for l in $DEVLINKS; do
		[ "$1" != "$l" ] ||
			return 0
	done
	return 1
}

get_dev() {
	local name retval value
	retval="$1"; shift
	name="$1"; shift

	[ -n "$retval" -a -n "$name" ] ||
		return 1

	case "$name" in
		UUID=*)
			[ "$ID_FS_UUID" = "${name#UUID=}" ] ||
				return 1
			;;
		LABEL=*)
			[ "$ID_FS_LABEL" = "${name#LABEL=}" ] ||
				return 1
			;;
		/dev/disk/by-uuid/*)
			[ "/dev/disk/by-uuid/$ID_FS_UUID_ENC" = "$name" ] ||
				return 1
			;;
		/dev/disk/by-label/*)
			[ "/dev/disk/by-label/$ID_FS_LABEL_ENC" = "$name" ] ||
				return 1
			;;
		/*)
			[ "$DEVNAME" = "$name" ] || devlinks_check "$name" ||
				return 1
			;;
		*:*)
			[ "$MAJOR" = "${name%:*}" -a "$MINOR" = "${name#*:}" ] ||
				return 1
			;;
		*)
			local value=$(( 0x$name ))
			[ "$MAJOR" = "$(( $value / 256 ))" -a "$MINOR" = "$(( $value % 256 ))" ] ||
				return 1
			;;
	esac
	eval "$retval=\"\$DEVNAME\""
}
