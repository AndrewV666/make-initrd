#!/bin/sh -efu

. sh-functions
. shell-error

ignore_missing=
if [ "${1-}" = '--optional' ]; then
	ignore_missing=1
	shift
fi

check_builtin() {
	local n="$1" builtin

	builtin="$kernel_modules_dir/modules.builtin"
	[ -f "$builtin" ] ||
		return 1

	[ -n "${n##*[_-]*}" ] ||
		n="$(printf '%s\n' "$n" |tr '_-' '.')"

	grep -xqs "^.*/$n\\.ko\$" "$builtin"
}

check_blacklist() {
	local m f

	f="${f##*/}"
	f="$(normalize_modname "${f%.ko*}")"

	for m in ${blacklist-}; do
		[ "$f" != "$m" ] || return
	done
	return 1
}

add_module() {
	local name n v
	name="$1"

	if check_builtin "$name"; then
		verbose "Builtin module \"$name\""
		return 0
	fi

	local modules= firmware=

	while read n v; do
		case "$n" in
			module)   modules="$modules $v"   ;;
			firmware) firmware="$firmware $v" ;;
		esac
	done <<-EOF
		`depinfo --set-version="$kernel" "$name" 2>/dev/null |
			sort -u`
	EOF

	if [ -z "$modules" ]; then
		[ -z "$ignore_missing" ] ||
			return 0
		fatal "No module \"$name\" found for kernel $kernel"
	fi

	for n in $modules; do
		check_blacklist "$n" ||
			continue
		verbose "Module '$name' is ignored because the '$n' is blacklisted"
		return
	done

	for n in $modules; do
		verbose "Adding module \"$n\""
		put-file "$n"
	done

	for n in $firmware; do
		verbose "Adding firmware file \"$n\""
		put-file "$n"
	done
}

for n; do
	if [ -n "${n##*[/\[\].*&^\$\\\\/]*}" ]; then
		add_module "$n"

	elif [ -n "${KERNEL_MODULES-}" ]; then
		find "$KERNEL_MODULES" -type f |egrep -e "$n" |
		while read m; do
			add_module "$m"
		done
	else
		fatal "Unable to handle pattern: $n"
	fi
done
