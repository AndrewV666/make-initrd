#!/bin/sh

lockd=/tmp

add_lock() {
	local sec=$(($2*10))
	while ! mkdir "$lockd/$1" >/dev/null 2>&1; do
		if [ "$sec" != '-' ] && [ $sec -eq 0 ]; then
			shell "It seems that the deadlock occurred."
			return 1
		fi
		sec=$(($sec-1))
		sleep 0.1
	done
}

del_lock() {
	/bin/nuke -- "$lockd/$1"
}

set_lock() {
	add_lock "$1" "${2-50}" || return 0
	trap "del_lock $1" HUP INT QUIT TERM EXIT
}

is_lock() {
	[ -d "$lockd/$1" ]
}

wait_unlock() {
	while is_lock "$1"; do
		sleep 0.1
	done
}

lock_udev() {
	mkdir -p "$lockd/udev"
	echo "$1"
}

verbose() {
	[ -n "$QUIET" ] || echo "$@"
}

shell() {
	# Disallow console access
	[ "$PANIC" != 0 ] || reboot

	if [ -n "$RESCUE_MODULES" ]; then
		local m
		for m in $RESCUE_MODULES; do
			modprobe -q "$m"
		done
	fi
	echo "$@"
	PS1='(initramfs) ' /bin/sh -i </dev/console >/dev/console 2>&1
}

run_scripts() {
	local s
	for s in /scripts/"$1"/*; do
		[ -x "$s" ] || continue
		verbose "Running $s ..."
		. "$s"
	done
}

load_modules() {
	[ ! -e /conf/modules-"$1" ] ||
	while read m; do
		[ -n "${m##\#*}" ] || continue
		modprobe -q $m
	done < /conf/modules-"$1"
}

configure_network() {
	# networking already configured thus bail out
	[ -n "$DEVICE" ] && [ -e /tmp/net-"$DEVICE".conf ] && return 0

	# support ip options see linux sources Documentation/nfsroot.txt
	case "$IPOPTS" in
		none|off)
			# Do nothing
			;;
		""|on|any)
			# Bring up device
			ipconfig "$DEVICE"
			;;
		dhcp|bootp|rarp|both)
			ipconfig -c "$IPOPTS" -d "$DEVICE"
			;;
		*)
			ipconfig -d "$IPOPTS"

			# grab device entry from ip option
			NEW_DEVICE="${IPOPTS#*:*:*:*:*:*}"
			if [ "$NEW_DEVICE" != "$IPOPTS" ]; then
				NEW_DEVICE="${NEW_DEVICE%:*}"
			else
				# wrong parse, possibly only a partial string
				NEW_DEVICE=
			fi
			if [ -n "$NEW_DEVICE" ]; then
				DEVICE="$NEW_DEVICE"
			fi
			;;
	esac

	# source relevant ipconfig output
	. /tmp/net-${DEVICE}.conf
}

get_dev() {
	local name retval value
	retval="$1"; shift
	name="$1"; shift

	case "$name" in
		UUID=*)
			[ "$ID_FS_UUID" = "${name#UUID=}" ] ||
				return 1
			;;
		LABEL=*)
			[ "$ID_FS_LABEL" = "${name#LABEL=}" ] ||
				return 1
			;;
		/*)
			[ "$DEVNAME" = "$name" ] ||
				return 1
			;;
		*:*)
			[ "$MAJOR" = "${name%:*}" -a "$MINOR" = "${name#*:}" ] ||
				return 1
			;;
		*)
			local value=$(( 0x$name ))
			[ "$MAJOR" = "$(( $value / 256 ))" -a "$MINOR" = "$(( $value % 256 ))" ] ||
				return 1
			;;
	esac
	eval "$retval=\"\$DEVNAME\""
}
