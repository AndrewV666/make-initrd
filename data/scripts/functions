#!/bin/sh

lockd=/tmp

add_lock() {
	local sec=$(($2*10))
	while ! mkdir "$lockd/$1" >/dev/null 2>&1; do
		if [ "$sec" != '-' ] && [ $sec -eq 0 ]; then
			shell "It seems that the deadlock occurred."
			return 1
		fi
		sec=$(($sec-1))
		sleep 0.1
	done
}

del_lock() {
	/bin/rm -rf -- "$lockd/$1"
}

set_lock() {
	add_lock "$1" "${2-50}" || return 0
	trap "del_lock $1" HUP INT QUIT TERM EXIT
}

is_lock() {
	[ -d "$lockd/$1" ]
}

wait_unlock() {
	while is_lock "$1"; do
		sleep 0.1
	done
}

lock_udev() {
	mkdir -p "$lockd/udev"
	echo "$1"
}

verbose() {
	[ -n "$QUIET" ] || echo "$@"
}

shell() {
	# Disallow console access
	[ "$PANIC" != 0 ] || reboot

	if [ -n "$RESCUE_MODULES" ]; then
		local m
		for m in $RESCUE_MODULES; do
			modprobe -q "$m"
		done
	fi
	echo "$@"
	PS1='(initramfs) ' /bin/sh -i +m </dev/console >/dev/console 2>&1
}

run_scripts() {
	local s
	for s in /scripts/"$1"/*; do
		[ -x "$s" ] || continue
		verbose "Running $s ..."
		. "$s"
	done
}

load_modules() {
	[ ! -e /conf/modules-"$1" ] ||
	while read m; do
		[ -n "${m##\#*}" ] || continue
		modprobe -q $m
	done < /conf/modules-"$1"
}

get_dev() {
	local name retval value
	retval="$1"; shift
	name="$1"; shift

	[ -n "$retval" -a -n "$name" ] ||
		return 1

	case "$name" in
		UUID=*)
			[ "$ID_FS_UUID" = "${name#UUID=}" ] ||
				return 1
			;;
		LABEL=*)
			[ "$ID_FS_LABEL" = "${name#LABEL=}" ] ||
				return 1
			;;
		/*)
			[ "$DEVNAME" = "$name" ] ||
				return 1
			;;
		*:*)
			[ "$MAJOR" = "${name%:*}" -a "$MINOR" = "${name#*:}" ] ||
				return 1
			;;
		*)
			local value=$(( 0x$name ))
			[ "$MAJOR" = "$(( $value / 256 ))" -a "$MINOR" = "$(( $value % 256 ))" ] ||
				return 1
			;;
	esac
	eval "$retval=\"\$DEVNAME\""
}
